# THIS IS BACKUP FILE functions_BK.sh
# DO NOT EDIT THIS FILE
# EDIT THE ACTUAL FILE functions.sh INSTEAD

gitup() {
  if git show-ref --verify --quiet refs/heads/main; then
    git checkout main
  else
    git checkout master
  fi
  git fetch --all
  git pull
}

gitupall() {
  # Stash only if there are changes
  if [[ -n "$(git status --porcelain)" ]]; then
    echo "Stashing local changes..."
    git stash push -m "Auto stash before updating branches"
  fi

  echo "Fetching all remote updates..."
  git fetch --all

  # Get current branch to return later
  current_branch=$(git rev-parse --abbrev-ref HEAD)

  echo "Updating all local branches..."
  for branch in $(git branch --format='%(refname:short)'); do
    echo "--------------------------"
    echo "Updating branch: $branch"
    git checkout "$branch" >/dev/null 2>&1
    git pull --ff-only || echo "‚ö†Ô∏è Could not fast-forward $branch"
  done

  echo "Switching back to $current_branch..."
  git checkout "$current_branch" >/dev/null 2>&1

  echo "‚ú® All branches updated!"

  # Apply stash back if one was created
  if git stash list | grep -q "Auto stash before updating branches"; then
    echo "Restoring stashed changes..."
    git stash pop
  fi
}

gitclean() {
  protected_branches=("main" "master" "$(git rev-parse --abbrev-ref HEAD)")

  echo "Fetching updates from origin..."
  git fetch -p

  echo "üîç Checking for local branches that were deleted from remote..."
  for branch in $(git for-each-ref --format='%(refname:short)' refs/heads/); do

    # Skip protected branches
    if [[ " ${protected_branches[*]} " =~ " ${branch} " ]]; then
      echo "‚õî Skipping protected branch: $branch"
      continue
    fi

    # Check if branch has no upstream (never pushed)
    upstream=$(git rev-parse --symbolic-full-name --abbrev-ref "$branch@{upstream}" 2>/dev/null)
    if [[ -z "$upstream" ]]; then
      echo "üõë Keeping local-only branch (no upstream): $branch"
      continue
    fi

    # Check if upstream branch exists on remote
    if ! git ls-remote --exit-code --heads origin "$branch" >/dev/null 2>&1; then
      echo "üóë Deleting branch (gone from remote): $branch"
      git branch -D "$branch"
    else
      echo "‚úî Keeping active branch: $branch"
    fi
  done
}

newfeature() {
  if [ -z "$1" ]; then
    echo "‚ùå Usage: newfeature \"<ticket>: <description>\""
    return 1
  fi

  # Step 1: Extract issue key (first token like OM-755)
  issue_key=$(echo "$1" | grep -oE '^[A-Za-z]+-[0-9]+')

  # Step 2: Remove issue key from the title to avoid duplication
  title=$(echo "$1" | sed "s/$issue_key//I")

  # Step 3: Clean the title (remove special chars, keep letters, numbers, spaces)
  clean_title=$(echo "$title" | tr -cd '[:alnum:] _-' | tr ' ' '_' )

  # Step 4: Normalize multiple underscores to a single one
  clean_title=$(echo "$clean_title" | sed 's/_\+/_/g')

  # Step 5: Trim leading/trailing underscores
  clean_title=$(echo "$clean_title" | sed 's/^_//;s/_$//')

  # Step 6: Lowercase conversion (optional, remove if you prefer uppercase)
  clean_title=$(echo "$clean_title" | tr '[:upper:]' '[:lower:]')

  # Step 7: Combine issue key and cleaned title
  branch_name="feature/${issue_key}_${clean_title}"

  # Step 8: Enforce max length (Git limit: 255, keep ours short approx 60)
  branch_name=$(echo "$branch_name" | cut -c1-60)

  # Step 9: Final cleanup (remove trailing underscore if cut occurs mid word)
  branch_name=$(echo "$branch_name" | sed 's/_$//')

  echo "üöÄ Creating branch: $branch_name"
  git checkout -b "$branch_name"
}